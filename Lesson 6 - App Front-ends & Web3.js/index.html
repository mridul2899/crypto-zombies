<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>CryptoZombies front-end</title>
    <script
      language="javascript"
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"
    ></script>
    <!--
      Chapter 1 - Intro to Web3.js
      To call a function on a smart contract, one needs to query an Ethereum node,
      and tell address of contract, function to call, parameters for function.
      Ethereum nodes communicate only in JSON-RPC format, which isn't human friendly.
      Web3.js abstracts queries and makes it easy to interact with contracts in a JS interface.

      To install web3.js -> npm install web3
      Or one may also download the minified .js file and include it in the project.
      In this chapter, we choose to do the latter for the sake of simplicity.
    -->
    <script
      language="javascript"
      type="text/javascript"
      src="web3.min.js"
    ></script>
    <!--
      Chapter 3 - Talking to Contracts - Part 1
      After deploying the contract on Ethereum, it gets a fixed address.
      This address is needed to talk to the smart contract.

      ABI stands for Application Binary Interface.
      It's a representation of a contract's methods in JSON format.
      It tells Web3.js how to format function calls so that contract understands.
      Solidity compiler gives the ABI when contract is compiled to deploy on Ethereum.
      Here, we've stored the ABI in cryptozombies_abi.js file.
    -->
    <script
      language="javascript"
      type="text/javascript"
      src="cryptozombies_abi.js"
    ></script>
  </head>
  <body>
    <script>
      // Chapter 3 - Talking to Contracts - Part 2
      var cryptoZombies;

      // Chapter 5 - MetaMask & Accounts - Part 1
      // MetaMask allows the user to manage multiple accounts in their extension.
      // The currently active account on the injected web3 variable can be seen by:
      var userAccount;

      function startApp() {
        var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
        cryptoZombies = new web3js.eth.Contract(
          cryptoZombiesABI,
          cryptoZombiesAddress
        );

        // Chapter 5 - MetaMask & Accounts - Part 2
        // Since the user can change the currently active account any time,
        // our app needs to monitor the variable, and update the UI accordingly.
        // We can do that with a setInterval loop, as follows:
        var accountInterval = setInterval(function () {
          // Check if account has changed
          if (web3.eth.accounts[0] !== userAccount) {
            userAccount = web3.eth.accounts[0];
            // Call some function to update the UI with the new account
            getZombiesByOwner(userAccount).then(displayZombies);
          }
        }, 100);
        // The above loop checks the userAccount variable every 100 milliseconds.
      }

      // Chapter 4 - Calling Contract Functions
      // Web3.js has 2 methods to call functions on contract - call and send.
      // Call is used for view and pure functions.
      // It runs on a local node and does not create a txn on the blockchain.

      // Note: Since view and pure are read-only and don't change state on the blockchain,
      // they don't cost gas and the user is not prompted to sign a txn with MetaMask.

      // Syntax: myContract.myMethod(params).call()

      // Send creates a txn and changes data on the blockchain.
      // Send is needed for any function that isn't view or pure.

      // Note: Sending a txn requires user to pay gas and will pop up MetaMask
      // to prompt user to sign the txn. This happens automatically when we use send().

      // Syntax: myContract.myMethod(params).send()

      // Solidity automatically creates getter functions for the public variables.
      // Their names are same as those of the variables.
      // Example: zombies(15) will fetch data from zombies array for the id 15 (16th element).

      // Note: The codes in this tutorial are compatible with Web3.js version 1.0.
      // Hence, the codes use promises instead of callbacks.

      function getZombieDetails(id) {
        return cryptoZombies.methods.zombies(id).call();
      }

      // 1. Define `zombieToOwner` here
      function zombieToOwner(id) {
        return cryptoZombies.methods.zombieToOwner(id).call();
      }

      // 2. Define `getZombiesByOwner` here
      function getZombiesByOwner(owner) {
        return cryptoZombies.methods.getZombiesByOwner(owner).call();
      }

      // Chapter 2 - Web3 Providers
      // Web3 Provider tells our code which node to interact with to handle reads and writes.
      // It's like setting the URL of remote web server for API calls in Web2 projects.
      // One can host their own Ethereum node as a provider.
      // Infura is a third-party service that maintains a set of nodes with a caching layer
      // for fast reads, which can be accessed for free for providers through their API.
      // https://infura.io/
      // Hence, it eliminates the need to maintain our own node.

      // For users to write to our DApp,
      // we need a way for users to sign transactions with their private keys.
      // Ethereum (most blockchains) uses a public/private key pair to digitally sign transactions.
      // Metamask is a browser extension that helps users securely manage their Ethereum accounts,
      // and private keys.
      // Note: Metamask uses Infura's servers under the hood as a Web3 provider.
      // It also gives the user to choose their own provider.

      // Metamask injects their web3 provider into the browser in the global JS object web3.
      // App can check if web3 exists and then use web3.currentProvider as its provider.

      // Template code to detect if the user has Metamask installed.
      window.addEventListener("load", function () {
        // Checking if Web3 has been injected by the browser (Mist/MetaMask)
        if (typeof web3 !== "undefined") {
          // Use Mist/MetaMask's provider
          web3js = new Web3(web3.currentProvider);
        } else {
          // Handle the case where the user doesn't have web3. Probably
          // show them a message telling them to install Metamask in
          // order to use our app.
        }

        // Now you can start your app & access web3js freely:
        startApp();
      });
    </script>
  </body>
</html>

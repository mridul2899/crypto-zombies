<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>CryptoZombies front-end</title>
    <script
      language="javascript"
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"
    ></script>
    <!--
      Chapter 1 - Intro to Web3.js
      To call a function on a smart contract, one needs to query an Ethereum node,
      and tell address of contract, function to call, parameters for function.
      Ethereum nodes communicate only in JSON-RPC format, which isn't human friendly.
      Web3.js abstracts queries and makes it easy to interact with contracts in a JS interface.

      To install web3.js -> npm install web3
      Or one may also download the minified .js file and include it in the project.
      In this chapter, we choose to do the latter for the sake of simplicity.
    -->
    <script
      language="javascript"
      type="text/javascript"
      src="web3.min.js"
    ></script>
    <!--
      Chapter 3 - Talking to Contracts - Part 1
      After deploying the contract on Ethereum, it gets a fixed address.
      This address is needed to talk to the smart contract.

      ABI stands for Application Binary Interface.
      It's a representation of a contract's methods in JSON format.
      It tells Web3.js how to format function calls so that contract understands.
      Solidity compiler gives the ABI when contract is compiled to deploy on Ethereum.
      Here, we've stored the ABI in cryptozombies_abi.js file.
    -->
    <script
      language="javascript"
      type="text/javascript"
      src="cryptozombies_abi.js"
    ></script>
  </head>
  <body>
    <script>
      // Chapter 3 - Talking to Contracts - Part 2
      var cryptoZombies;

      function startApp() {
        var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
        cryptoZombies = new web3js.eth.Contract(
          cryptoZombiesABI,
          cryptoZombiesAddress
        );
      }
      // Chapter 2 - Web3 Providers
      // Web3 Provider tells our code which node to interact with to handle reads and writes.
      // It's like setting the URL of remote web server for API calls in Web2 projects.
      // One can host their own Ethereum node as a provider.
      // Infura is a third-party service that maintains a set of nodes with a caching layer
      // for fast reads, which can be accessed for free for providers through their API.
      // https://infura.io/
      // Hence, it eliminates the need to maintain our own node.

      // For users to write to our DApp,
      // we need a way for users to sign transactions with their private keys.
      // Ethereum (most blockchains) uses a public/private key pair to digitally sign transactions.
      // Metamask is a browser extension that helps users securely manage their Ethereum accounts,
      // and private keys.
      // Note: Metamask uses Infura's servers under the hood as a Web3 provider.
      // It also gives the user to choose their own provider.

      // Metamask injects their web3 provider into the browser in the global JS object web3.
      // App can check if web3 exists and then use web3.currentProvider as its provider.

      // Template code to detect if the user has Metamask installed.
      window.addEventListener("load", function () {
        // Checking if Web3 has been injected by the browser (Mist/MetaMask)
        if (typeof web3 !== "undefined") {
          // Use Mist/MetaMask's provider
          web3js = new Web3(web3.currentProvider);
        } else {
          // Handle the case where the user doesn't have web3. Probably
          // show them a message telling them to install Metamask in
          // order to use our app.
        }

        // Now you can start your app & access web3js freely:
        startApp();
      });
    </script>
  </body>
</html>
